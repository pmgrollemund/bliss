---
title: "Introduction to BLiSS method"
author: "Paul-Marie Grollemund"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Introduction to BliSS method}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r,echo=TRUE,message=FALSE, warning=FALSE}
  library(bliss)
```

This vignette describes step by step how to use the BLiSS method. 
Below, you can find the following implemented features:

* Simulate data to test the BLiSS model
* Obtain a sample of the posterior distribution with a Gibbs Sampler
* Plot the posterior distribution of the coefficient function and the posterior
distribution of the support
* Compute the different Bayesian estimators 

# One single functional covariate case

## Simulate a data set

In order to simulate a proper dataset for Bliss application, some characteristics 
must be specified: 

* $n$ (the number of observations), 
* $p$ (number of instant of measure), 
* beta$\_$types (the shape of the coefficient function), and 
* grids$\_$lim, a 2-vector (to define the domain of curves $x_{i}(.)$). 

Based on these parameters, data can be simulated 
(curves $x_{i}(.)$ and real values $y_{i}$)
from the functional linear regression model by using the *sim* function, 
as suggested in the following chunck.


```{r ,eval=TRUE,include = TRUE}
  set.seed(1)
  param <- list(                        # define the "param" to simulate data
                Q=1,                    # the number of functional covariate
                n=100,                  # n is the sample size and p is the
                p=c(50),                # number of time observations of the curves
                beta_types=c("smooth"), # define the shape of the "true" coefficient function
                grids_lim=list(c(0,1))) # Give the beginning and the end of the observation's domain of the functions.

  data <- sim(param) # Simulate the data
```

## Apply the Bliss method

The *fit$\_$Bliss* function provides the following outputs:

* a posterior sample of the Bliss model, 
* an approximation of the posterior distribution of the coefficient function, 
* a piecewise constant estimate (stepfunction) of the coefficient function, 
which is computed thanks to an optimization algorithm,
* an estimation of the support, which shoulb be useful if your purpose is to 
detect periods for which the functional coviarate has an (linear) impact on the
dependent scalar variable,
* the posterior densities of the posterior sample, which should be used to 
compute model choice criterion.

An important required argument of the previous function is **param**, 
which is a list containing: 

* **iter**, the number of iterations for the Gibbs algorithm, 
* **burnin** the number of iteration to drop at the beginning of the Gibbs Sampler, 
* **K**, hyperparameter $K$ of the Bliss model,
* **grids**, the grid of instant for which the curves $x_{i}(.)$ are measured, 
* **prior$\_$beta**, an argument specifying a prior distribution of the slope coefficient $\beta$,
(only the **Ridge$\_$Zellner** case is considered in this vignette),
* and **phi$\_\ell$**, an argument specifying a prior distribution for $\ell$ 
the half-width of the intervals 
(only the **Gamma`** case is considered in this vignette),

```{r ,eval=TRUE, include = TRUE}
  param <- list(            # define the required values of the Bliss method.
                iter=1e3,   # The number of iteration of the main numerical algorithm of Bliss.
                burnin=2e2, # The number of burnin iteration for the Gibbs Sampler
                K=c(3))     # The number of intervals of the beta

   
  res_bliss<-fit_Bliss(data=data,param=param,verbose=TRUE)
  
  # Structure of a Bliss object
  str(res_bliss)
```

## Plot the result

We give here the code to obtain representations of the *a posteriori* distribution. First, we give the code to obtain a posteriori probabilities $\alpha(t|D)$, relative to the support. Then, the *image$\_$Bliss* function is used to represent the subsequent distribution of the coefficient function.

```{r ,eval=TRUE, include = TRUE,fig.height=5,fig.width=7}
  param$ylim <- range(range(res_bliss$beta_posterior_density[[1]]$grid_beta_t),
                      c(-5,5))
  param$cols <- rev(heat.colors(100))
  image_Bliss(res_bliss$beta_posterior_density,param,q=1)
  lines(res_bliss$data$grids[[1]],res_bliss$Bliss_estimate[[1]],type="s",lwd=2)
  lines(res_bliss$data$grids[[1]],res_bliss$data$betas[[1]],col=2,lwd=2,type="s")
```


```{r ,eval=TRUE, include = TRUE,fig.height=5,fig.width=7}
  ylim <- range(range(res_bliss$Bliss_estimate[[1]]),
                range(res_bliss$Smooth_estimate[[1]]))
  plot_bliss(res_bliss$data$grids[[1]],
             res_bliss$Bliss_estimate[[1]],lwd=2)
  lines_bliss(res_bliss$data$grids[[1]],
             res_bliss$Smooth_estimate[[1]],lty=2)
```

# Several functional covariates

To avoid execution lengths, this section is not executed. Please, give it a try.

## Simulate the dataset

```{r ,eval=FALSE, include = TRUE}
   param <- list(Q=2,
                 n=300,
                 p=c(40,60),
                 beta_shapes=c("simple","smooth"),
                 grids_lim=list(c(0,1),c(0,2)))

  data <- sim(param)
```

## Apply the Bliss method
```{r ,eval=FALSE, include = TRUE}
  param <- list(       # define the required values of the Bliss method.
     iter=1e3,         # The number of iteration of the main numerical algorithm of Bliss.
     burnin=2e2,       # The number of burnin iteration for the Gibbs Sampler
     K=c(3,3))         # The number of intervals of the beta

  res_Bliss_mult <- fit_Bliss(data=data,param=param)
```

## Plot the result
```{r ,eval=FALSE, include = TRUE,fig.height=5,fig.width=7}
   q <- 1
   param$ylim <- range(range(res_Bliss_mult$beta_posterior_density[[q]]$grid_beta_t),
                       c(-5,5))
   param$cols <- rev(heat.colors(100))
   image_Bliss(res_Bliss_mult$beta_posterior_density,param,q=q)
   lines(res_Bliss_mult$data$grids[[q]],res_Bliss_mult$Bliss_estimate[[q]],type="s",lwd=2)
   lines(res_Bliss_mult$data$grids[[q]],res_Bliss_mult$data$betas[[q]],col=2,lwd=2,type="s")

  ylim <- range(range(res_Bliss_mult$Bliss_estimate[[q]]),
                 range(res_Bliss_mult$Smooth_estimate[[q]]))
   plot_bliss(res_Bliss_mult$data$grids[[q]],
              res_Bliss_mult$Bliss_estimate[[q]],lwd=2,ylim=ylim)
   lines(res_Bliss_mult$data$grids[[q]],
         res_Bliss_mult$Smooth_estimate[[q]],lty=2)


   q <- 2
   param$ylim <- range(range(res_Bliss_mult$beta_posterior_density[[q]]$grid_beta_t),
                       c(-5,5))
   param$cols <- rev(heat.colors(100))
   image_Bliss(res_Bliss_mult$beta_posterior_density,param,q=q)
   lines(res_Bliss_mult$data$grids[[q]],res_Bliss_mult$Bliss_estimate[[q]],type="s",lwd=2)
   lines(res_Bliss_mult$data$grids[[q]],res_Bliss_mult$data$betas[[q]],col=2,lwd=2,type="l")
   
   ylim <- range(range(res_Bliss_mult$Bliss_estimate[[q]]),
                 range(res_Bliss_mult$Smooth_estimate[[q]]))
   plot_bliss(res_Bliss_mult$data$grids[[q]],
              res_Bliss_mult$Bliss_estimate[[q]],lwd=2,ylim=ylim)
   lines(res_Bliss_mult$data$grids[[q]],
         res_Bliss_mult$Smooth_estimate[[q]],lty=2)
```

# Session informations
```{r session,echo=FALSE,message=FALSE, warning=FALSE}
  sessionInfo()
```
















